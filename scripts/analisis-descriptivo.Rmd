---
title: "An√°lisis de Accidentes de Tr√°fico en Madrid (2019-2023)"
author: "Pau Garcia Orengo, Vanessa Machordom Torres, Ditmar Estrada Bernuy"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
    fig_width: 7
    fig_height: 5
    df_print: kable
    latex_engine: xelatex
    keep_tex: false
geometry: margin=0.75in
fontsize: 10pt
urlcolor: blue
linkcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.align = 'center',
  out.width = "90%",
  fig.width = 7,
  fig.height = 5,
  tidy = FALSE  # Cambiado a FALSE para usar listings en su lugar
)

# Configuraci√≥n global para tablas kable
options(knitr.kable.NA = '')

# Configuraci√≥n para ancho de salida de texto
options(width = 75)
```

# Configuraci√≥n del Entorno

## Instalaci√≥n de Paquetes

```{r instalacion, eval=FALSE}
# Ejecutar solo si los paquetes no est√°n instalados
install.packages("corrplot")
install.packages("sf")
install.packages("leaflet")
install.packages(c("sf", "dplyr", "ggplot2", "scales"))
```

## Carga de Librer√≠as

```{r librerias}
# Manipulaci√≥n y visualizaci√≥n de datos
library(dplyr)
library(ggplot2)
library(lubridate)
library(stringr)
library(tidyr)
library(scales)

# An√°lisis espacial
library(sf)
library(leaflet)

# An√°lisis estad√≠stico
library(corrplot)
library(cluster)
library(factoextra)

library(knitr)
library(kableExtra)
```

# Carga y Preparaci√≥n de Datos

## Importaci√≥n del Dataset

```{r carga-datos}
# Cargar el archivo CSV con datos de accidentes y meteorolog√≠a
accidents_clean_data <- read.csv("../data/processed/accidentes_madrid_con_weather.csv", 
                                 header = TRUE, 
                                 sep = ",")
```

## Exploraci√≥n Inicial del Dataset

```{r exploracion-inicial}
# Dimensiones del dataset
cat("### RESUMEN GENERAL DEL DATASET ###\n\n")
cat(sprintf("üìä Dimensiones: %s observaciones √ó %s variables\n", 
            format(nrow(accidents_clean_data), big.mark = ","),
            ncol(accidents_clean_data)))
cat(sprintf("üìÖ Per√≠odo: %s a %s\n", 
            min(as.Date(accidents_clean_data$time)), 
            max(as.Date(accidents_clean_data$time))))
```

### Estructura de Variables

```{r estructura-variables}
# Crear tabla resumen de estructura de variables
estructura_df <- data.frame(
  Variable = names(accidents_clean_data),
  Tipo = sapply(accidents_clean_data, function(x) class(x)[1]),
  NAs = sapply(accidents_clean_data, function(x) sum(is.na(x))),
  Porcentaje_NA = sapply(accidents_clean_data, 
                         function(x) round(mean(is.na(x)) * 100, 1)),
  Valores_Unicos = sapply(accidents_clean_data, 
                          function(x) length(unique(x)))
)

# Ordenar por porcentaje de NAs descendente
estructura_df <- estructura_df %>%
  arrange(desc(Porcentaje_NA))

# Mostrar tabla con formato profesional
estructura_df %>%
  kable(format = "latex", 
        booktabs = TRUE,
        caption = "Estructura y caracter√≠sticas de las variables del dataset",
        col.names = c("Variable", "Tipo", "NAs", "Pct NA", "Valores √∫nicos"),
        align = c("l", "c", "r", "r", "r")) %>%
  kable_styling(latex_options = c("striped", "scale_down", "HOLD_position"),
                font_size = 8,
                full_width = FALSE) %>%
  row_spec(0, bold = TRUE)
```

### Resumen Estad√≠stico de Variables Num√©ricas

```{r resumen-numericas}
# Seleccionar solo variables num√©ricas
vars_numericas <- accidents_clean_data %>%
  select(where(is.numeric))

# Crear resumen estad√≠stico
if(ncol(vars_numericas) > 0) {
  resumen_num <- data.frame(
    Variable = names(vars_numericas),
    Media = sapply(vars_numericas, mean, na.rm = TRUE),
    Mediana = sapply(vars_numericas, median, na.rm = TRUE),
    Desv_Est = sapply(vars_numericas, sd, na.rm = TRUE),
    Minimo = sapply(vars_numericas, min, na.rm = TRUE),
    Maximo = sapply(vars_numericas, max, na.rm = TRUE)
  )
  
  resumen_num %>%
    mutate(across(where(is.numeric), ~round(., 2))) %>%
    kable(format = "latex", 
          booktabs = TRUE,
          caption = "Estad√≠sticas descriptivas de variables num√©ricas",
          col.names = c("Variable", "Media", "Mediana", "Desv. Est.", 
                       "M√≠nimo", "M√°ximo"),
          align = c("l", rep("r", 5))) %>%
    kable_styling(latex_options = c("striped", "HOLD_position"),
                  font_size = 9,
                  full_width = FALSE) %>%
    row_spec(0, bold = TRUE)
}
```

### Variables Categ√≥ricas Principales

```{r resumen-categoricas}
# Identificar variables categ√≥ricas con pocos valores √∫nicos
vars_categoricas <- accidents_clean_data %>%
  select(where(is.character)) %>%
  select(where(~length(unique(.)) <= 20))

# Crear resumen de frecuencias para variables categ√≥ricas clave
if(ncol(vars_categoricas) > 0) {
  cat("\n**Variables categ√≥ricas identificadas:**\n\n")
  cat(paste("-", names(vars_categoricas), collapse = "\n"))
}
```

### Distribuci√≥n de la Variable Objetivo: Lesividad

```{r lesividad-detalle}
# An√°lisis detallado de lesividad
lesividad_freq <- accidents_clean_data %>%
  filter(!is.na(lesividad)) %>%
  count(lesividad) %>%
  mutate(Porcentaje = round(n / sum(n) * 100, 2)) %>%
  arrange(desc(n))

lesividad_freq %>%
  kable(format = "latex", 
        booktabs = TRUE,
        caption = "Distribuci√≥n de tipos de lesividad en accidentes",
        col.names = c("Tipo de Lesividad", "Frecuencia", "Porcentaje"),
        align = c("l", "r", "r")) %>%
  kable_styling(latex_options = c("striped", "HOLD_position"),
                font_size = 9,
                full_width = FALSE) %>%
  row_spec(0, bold = TRUE) %>%
  column_spec(1, width = "8cm")
```

### Calidad de Datos: Variables con Datos Faltantes

```{r missing-data-viz}
# Resumen visual de datos faltantes
missing_data <- estructura_df %>%
  filter(Porcentaje_NA > 0) %>%
  select(Variable, NAs, Porcentaje_NA) %>%
  arrange(desc(Porcentaje_NA))

if(nrow(missing_data) > 0) {
  missing_data %>%
    head(15) %>%
    kable(format = "latex", 
          booktabs = TRUE,
          caption = "Top 15 variables con mayor proporci√≥n de datos faltantes",
          col.names = c("Variable", "Cantidad NAs", "Pct Faltante"),
          align = c("l", "r", "r")) %>%
    kable_styling(latex_options = c("striped", "HOLD_position"),
                  font_size = 9,
                  full_width = FALSE) %>%
    row_spec(0, bold = TRUE)
} else {
  cat("‚úÖ No se encontraron datos faltantes en el dataset.\n")
}
```

## Limpieza de Datos

### Normalizaci√≥n de Valores Faltantes

```{r limpieza-na}
# Estandarizar valores faltantes y limpiar espacios en blanco
accidents_clean_data <- accidents_clean_data %>%
  # Eliminar espacios en blanco en columnas de texto
  mutate(across(where(is.character), ~str_trim(.))) %>%
  
  # Reemplazar valores problem√°ticos por NA
  mutate(across(where(is.character),
                ~case_when(
                  . %in% c("", "NA", "N/A", "No se registr√≥", "No se registro",
                           "null", "NULL", "Sin dato", "Desconocido") ~ NA_character_,
                  TRUE ~ .
                )))
```

### An√°lisis de Valores Faltantes

```{r analisis-na}
# Calcular porcentaje de valores faltantes por columna
missing_summary <- accidents_clean_data %>%
  summarise(across(everything(), ~mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "columna", values_to = "porcentaje_na") %>%
  arrange(desc(porcentaje_na))

# Mostrar resumen de valores faltantes con formato ajustado
missing_summary %>%
  kable(format = "latex", booktabs = TRUE, 
        digits = 2,
        col.names = c("Columna", "% NA"),
        caption = "Porcentaje de valores faltantes por columna") %>%
  kable_styling(latex_options = c("striped", "scale_down", "HOLD_position"),
                font_size = 9,
                full_width = FALSE)

# Contar valores √∫nicos en columnas categ√≥ricas
valores_unicos <- sapply(accidents_clean_data[, sapply(accidents_clean_data, is.character)], 
                         function(x) length(unique(x)))

data.frame(
  Columna = names(valores_unicos),
  Valores_Unicos = valores_unicos
) %>%
  kable(format = "latex", booktabs = TRUE,
        caption = "Valores √∫nicos en columnas categ√≥ricas") %>%
  kable_styling(latex_options = c("striped", "scale_down", "HOLD_position"),
                font_size = 9,
                full_width = FALSE)
```

## Ingenier√≠a de Caracter√≠sticas

### Variables Temporales

```{r variables-temporales}
# Extraer componentes de fecha y tiempo
accidents_clean_data$fecha <- as.Date(accidents_clean_data$time)
accidents_clean_data$anio <- year(accidents_clean_data$fecha)
accidents_clean_data$hora <- hour(accidents_clean_data$time)
accidents_clean_data$dia_semana <- wday(accidents_clean_data$time, label = TRUE, abbr = FALSE)
accidents_clean_data$mes <- month(accidents_clean_data$time, label = TRUE)

# Crear variable de estaci√≥n del a√±o
accidents_clean_data$estacion <- case_when(
  accidents_clean_data$mes %in% c("diciembre", "enero", "febrero") ~ "Invierno",
  accidents_clean_data$mes %in% c("marzo", "abril", "mayo") ~ "Primavera",
  accidents_clean_data$mes %in% c("junio", "julio", "agosto") ~ "Verano",
  accidents_clean_data$mes %in% c("septiembre", "octubre", "noviembre") ~ "Oto√±o"
)
```

### Franjas Horarias y Per√≠odos

```{r franja-horaria}
# Clasificar accidentes por franja horaria
accidents_clean_data$franja_horaria <- case_when(
  accidents_clean_data$hora >= 6 & accidents_clean_data$hora < 12 ~ "Ma√±ana",
  accidents_clean_data$hora >= 12 & accidents_clean_data$hora < 18 ~ "Tarde",
  accidents_clean_data$hora >= 18 & accidents_clean_data$hora < 24 ~ "Noche",
  TRUE ~ "Madrugada"
)

# Clasificar fin de semana vs entre semana
accidents_clean_data$es_fin_de_semana <- ifelse(
  accidents_clean_data$dia_semana %in% c("s√°bado", "domingo"), "S√≠", "No"
)
```

### Variables Meteorol√≥gicas Derivadas

```{r variables-meteorologicas}
# Categorizar temperatura en rangos
accidents_clean_data$categoria_temp <- case_when(
  accidents_clean_data$wx_temperature < 5 ~ 
    "Fr√≠o (< 5¬∞C)",
  accidents_clean_data$wx_temperature >= 5 & 
    accidents_clean_data$wx_temperature < 15 ~ 
    "Templado (5-15¬∞C)",
  accidents_clean_data$wx_temperature >= 15 & 
    accidents_clean_data$wx_temperature < 25 ~ 
    "C√°lido (15-25¬∞C)",
  accidents_clean_data$wx_temperature >= 25 ~ 
    "Caluroso (> 25¬∞C)"
)

# Crear indicador binario de precipitaci√≥n
accidents_clean_data$hubo_lluvia <- ifelse(
  accidents_clean_data$wx_precipitation > 0, 
  "S√≠", 
  "No"
)
```

### Clasificaci√≥n de Gravedad de Lesiones

```{r gravedad-binaria}
# Crear variable de gravedad simplificada
accidents_clean_data <- accidents_clean_data %>%
  mutate(gravedad_binaria = case_when(
    # Casos leves
    grepl("s√≥lo en el lugar|Sin asistencia|ambulatoria", 
          lesividad, 
          ignore.case = TRUE) ~ "Leve",
    
    # Casos graves
    grepl("Ingreso|urgencias|centro de salud|mutua|Fallecido", 
          lesividad, 
          ignore.case = TRUE) ~ "Grave",
    
    # Casos sin informaci√≥n
    lesividad == "Se desconoce" | 
      is.na(lesividad) ~ "Desconocido",
    
    # Otros casos
    TRUE ~ "Otro"
  ))
```

## Resumen del Dataset Procesado

```{r resumen-final}
# Estructura general del dataset
cat("Estructura del dataset procesado:\n")
cat(sprintf("Dimensiones: %d filas x %d columnas\n", 
            nrow(accidents_clean_data), 
            ncol(accidents_clean_data)))

# Estad√≠sticas descriptivas - solo mostrar las primeras variables num√©ricas
cat("\nEstad√≠sticas descriptivas (primeras variables num√©ricas):\n")
numericas_idx <- which(sapply(accidents_clean_data, is.numeric))[1:min(5, sum(sapply(accidents_clean_data, is.numeric)))]
summary(accidents_clean_data[, numericas_idx])

# Conteo de valores faltantes por variable
na_counts <- sapply(accidents_clean_data, function(x) sum(is.na(x)))
data.frame(
  Variable = names(na_counts),
  NA_Count = na_counts
) %>%
  filter(NA_Count > 0) %>%
  kable(format = "latex", booktabs = TRUE,
        caption = "Conteo de valores faltantes",
        col.names = c("Variable", "NAs")) %>%
  kable_styling(latex_options = c("striped", "scale_down", "HOLD_position"),
                font_size = 8,
                full_width = FALSE)

# Primeras filas del dataset
head(accidents_clean_data, 5) %>%
  select(1:6) %>%
  kable(format = "latex", booktabs = TRUE,
        caption = "Primeras filas del dataset (primeras 6 columnas)") %>%
  kable_styling(latex_options = c("striped", "scale_down", "HOLD_position"),
                font_size = 7,
                full_width = FALSE)
```

# An√°lisis General del Conjunto de Datos

## Distribuci√≥n por Tipo de Accidente

```{r tipo-accidente}
accidents_clean_data %>%
  filter(!is.na(tipo_accidente)) %>%
  count(tipo_accidente) %>%
  mutate(tipo_accidente = reorder(tipo_accidente, n)) %>%
  ggplot(aes(x = tipo_accidente, y = n)) +
  geom_col(fill = "steelblue") +
  geom_text(aes(label = n), hjust = -0.1) +
  coord_flip() +
  labs(
    title = "Distribuci√≥n de tipos de accidente en Madrid (2019‚Äì2023)",
    x = "Tipo de accidente",
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.text.y = element_text(size = 9)
  )
```

## Distribuci√≥n por Distrito

```{r accidentes-distrito}
# Calcular total de accidentes por distrito
accidentes_por_distrito <- accidents_clean_data %>%
  filter(!is.na(distrito)) %>%
  group_by(distrito) %>%
  summarise(total_accidentes = n()) %>%
  arrange(desc(total_accidentes))

# Visualizaci√≥n
ggplot(accidentes_por_distrito, 
       aes(x = reorder(distrito, total_accidentes), y = total_accidentes, fill = distrito)) +
  geom_col() +
  geom_text(aes(label = total_accidentes), vjust = 0.5, hjust = -0.1) +
  coord_flip() +
  labs(
    title = "Accidentes de tr√°fico por distrito (Madrid 2019‚Äì2023)",
    x = "Distrito",
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

## Distribuci√≥n por Tipo de Veh√≠culo

```{r tipo-vehiculo}
# Calcular accidentes por tipo de veh√≠culo
accidentes_por_tipo_vehiculo <- accidents_clean_data %>%
  filter(!is.na(tipo_vehiculo)) %>%
  group_by(tipo_vehiculo) %>%
  summarise(total_accidentes = n()) %>%
  arrange(desc(total_accidentes))

# Visualizaci√≥n
ggplot(accidentes_por_tipo_vehiculo, 
       aes(x = reorder(tipo_vehiculo, total_accidentes), y = total_accidentes)) +
  geom_col(fill = "tomato") +
  coord_flip() +
  labs(
    title = "Accidentes de tr√°fico por tipo de veh√≠culo (Madrid 2019‚Äì2023)",
    x = "Tipo de veh√≠culo",
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal()
```

## Gravedad seg√∫n Tipo de Accidente

```{r gravedad-tipo-accidente}
# Filtrar datos sin NA en tipo de accidente
accidents_clean_data_sin_na <- accidents_clean_data %>%
  filter(!is.na(tipo_accidente))

# Visualizaci√≥n de proporci√≥n de gravedad por tipo de accidente
ggplot(accidents_clean_data_sin_na, aes(x = tipo_accidente, fill = gravedad_binaria)) +
  geom_bar(position = "fill") +
  coord_flip() +
  labs(
    title = "Gravedad seg√∫n tipo de accidente",
    x = "Tipo de accidente", 
    y = "Proporci√≥n"
  ) +
  theme_minimal()
```

## Distribuci√≥n Temporal B√°sica

### Accidentes por D√≠a de la Semana

```{r dia-semana}
ggplot(accidents_clean_data, aes(x = dia_semana)) +
  geom_bar(fill = "steelblue") +
  labs(
    title = "Accidentes por d√≠a de la semana",
    x = "D√≠a", 
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal()
```

### Accidentes por Mes

```{r accidentes-mes}
ggplot(accidents_clean_data, aes(x = mes)) +
  geom_bar(fill = "forestgreen") +
  labs(
    title = "Accidentes por mes",
    x = "Mes", 
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# An√°lisis Meteorol√≥gico

## Accidentes por Condici√≥n Meteorol√≥gica (Totales)

```{r accidentes-clima-total}
# Contar accidentes por estado meteorol√≥gico
accidentes_clima <- accidents_clean_data %>%
  filter(!is.na(estado_meteorol_gico)) %>%
  count(estado_meteorol_gico) %>%
  arrange(desc(n))

# Visualizaci√≥n
ggplot(accidentes_clima, aes(x = reorder(estado_meteorol_gico, n), y = n)) +
  geom_col(fill = "skyblue") +
  geom_text(aes(label = n), hjust = -0.1) +
  coord_flip() +
  labs(
    title = "Accidentes seg√∫n estado meteorol√≥gico (Madrid 2019‚Äì2023)",
    x = "Estado meteorol√≥gico",
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.text.y = element_text(size = 10)
  )
```

## Media de Accidentes Diarios por Condici√≥n Meteorol√≥gica

```{r accidentes-clima-media}
# Calcular media de accidentes por d√≠a seg√∫n condici√≥n meteorol√≥gica
accidentes_clima <- accidents_clean_data %>%
  filter(!is.na(estado_meteorol_gico)) %>%
  mutate(fecha = as.Date(time)) %>%
  group_by(estado_meteorol_gico, fecha) %>%
  summarise(accidentes_dia = n(), .groups = 'drop') %>%
  group_by(estado_meteorol_gico) %>%
  summarise(media = mean(accidentes_dia)) %>%
  arrange(desc(media))

# Visualizaci√≥n
ggplot(accidentes_clima, aes(x = reorder(estado_meteorol_gico, media), y = media)) +
  geom_col(fill = "grey") +
  geom_text(aes(label = round(media, 1)), hjust = -0.1) +
  coord_flip() +
  labs(
    title = "Media de accidentes por d√≠a seg√∫n estado meteorol√≥gico (Madrid 2019‚Äì2023)",
    x = "Estado meteorol√≥gico",
    y = "Media de accidentes por d√≠a"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.text.y = element_text(size = 10)
  )
```

## Accidentes seg√∫n Categor√≠a de Temperatura

```{r accidentes-temperatura}
# Filtrar datos con temperatura categorizada
accidents_clean_data_temp <- accidents_clean_data %>%
  filter(!is.na(categoria_temp))

# Visualizaci√≥n
ggplot(accidents_clean_data_temp, aes(x = categoria_temp)) +
  geom_bar(fill = "orange") +
  labs(
    title = "Accidentes seg√∫n categor√≠a de temperatura",
    x = "Temperatura", 
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal()
```

## Accidentes con y sin Lluvia

```{r accidentes-lluvia}
# Filtrar datos con informaci√≥n de lluvia
accidents_clean_data_lluvia <- accidents_clean_data %>%
  filter(!is.na(hubo_lluvia))

# Visualizaci√≥n
ggplot(accidents_clean_data_lluvia, aes(x = hubo_lluvia)) +
  geom_bar(fill = "dodgerblue") +
  labs(
    title = "Accidentes seg√∫n presencia de lluvia",
    x = "¬øLlovi√≥?", 
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal()
```

# An√°lisis Temporal

## Distribuci√≥n por A√±o

```{r accidentes-anio}
# Calcular accidentes por a√±o
accidentes_por_anio <- accidents_clean_data %>%
  group_by(anio) %>%
  summarise(total_accidentes = n())

# Visualizaci√≥n
ggplot(accidentes_por_anio, aes(x = factor(anio), y = total_accidentes)) +
  geom_col(fill = "steelblue") +
  geom_text(aes(label = total_accidentes), vjust = -0.5, size = 4) +
  labs(
    title = "N√∫mero de accidentes por a√±o en Madrid (2019‚Äì2023)",
    x = "A√±o",
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal()
```

## Distribuci√≥n por Hora del D√≠a

```{r distribucion-hora}
ggplot(accidents_clean_data, aes(x = hora)) +
  geom_bar(fill = "#DE2D27") +
  labs(
    title = "Distribuci√≥n de accidentes por hora del d√≠a",
    x = "Hora", 
    y = "N√∫mero de accidentes"
  ) +
  theme_minimal()
```

# An√°lisis Temporal Avanzado

## Configuraci√≥n para An√°lisis de D√≠as Festivos

```{r config-festivos}
# Par√°metros para an√°lisis temporal con festivos
TZ_LOCAL <- "Europe/Madrid"
COUNTRY <- "ES"

# Asegurar que tenemos la librer√≠a necesaria
if (!require("jsonlite")) install.packages("jsonlite")
library(jsonlite)
```

## Media de Accidentes por D√≠a de la Semana

```{r accidentes-dia-semana-media}
# Convertir fecha a formato Date
fecha_date <- as.Date(accidents_clean_data$time, tz = TZ_LOCAL)

# Agregar accidentes por fecha
daily <- as.data.frame(table(fecha_date))
names(daily) <- c("fecha", "accidents")
daily$fecha <- as.Date(daily$fecha)

# Obtener d√≠a de la semana
wd <- as.POSIXlt(daily$fecha)$wday
map_es <- c("domingo", "lunes", "martes", "mi√©rcoles", "jueves", "viernes", "s√°bado")
lvl_es <- c("lunes", "martes", "mi√©rcoles", "jueves", "viernes", "s√°bado", "domingo")
daily$day <- factor(map_es[wd + 1], levels = lvl_es, ordered = TRUE)

# Calcular estad√≠sticas por d√≠a de la semana
sum_by <- aggregate(accidents ~ day, data = daily, sum)
n_by <- aggregate(fecha ~ day, data = daily, function(x) length(unique(x)))
names(n_by)[2] <- "n_dias"

# Calcular media: total de accidentes / n√∫mero de d√≠as de ese tipo
stats <- merge(sum_by, n_by, by = "day", all = TRUE)
stats$mean_acc <- stats$accidents / stats$n_dias

# Mostrar estad√≠sticas con formato ajustado
stats %>%
  kable(format = "latex", booktabs = TRUE, 
        digits = 2,
        col.names = c("D√≠a", "Total accidentes", "N¬∞ d√≠as", "Media"),
        caption = "Estad√≠sticas por d√≠a de la semana") %>%
  kable_styling(latex_options = c("striped", "HOLD_position"),
                font_size = 10,
                full_width = FALSE)
```

```{r plot-dia-semana-media, fig.cap="Media de accidentes por d√≠a de la semana"}
# Visualizaci√≥n de media de accidentes por d√≠a
ggplot(stats, aes(x = day, y = mean_acc)) +
  geom_col(fill = "grey70", color = "grey30") +
  geom_text(aes(label = sprintf("%.2f", mean_acc)), vjust = -0.4, size = 3.5) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.08))) +
  labs(
    title = "Media de accidentes por d√≠a de la semana (2019‚Äì2023)",
    x = "D√≠a de la semana",
    y = "Accidentes por d√≠a de la semana (media)"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    panel.grid.minor = element_blank()
  )
```

## Obtenci√≥n de D√≠as Festivos

```{r obtencion-festivos}
# Funci√≥n para obtener festivos desde API Nager.Date
get_holidays <- function(year, country = COUNTRY) {
  url <- paste0("https://date.nager.at/api/v3/PublicHolidays/", year, "/", country)
  json <- try(jsonlite::fromJSON(url), silent = TRUE)
  
  if (inherits(json, "try-error") || length(json) == 0) {
    warning("No se pudieron obtener festivos para ", year)
    return(data.frame(date = as.Date(character()), stringsAsFactors = FALSE))
  }
  
  data.frame(
    date = as.Date(json$date),
    localName = json$localName,
    name = json$name,
    fixed = json$fixed,
    global = json$global,
    stringsAsFactors = FALSE
  )
}

# Obtener a√±os √∫nicos del dataset
years <- sort(unique(format(as.Date(accidents_clean_data$time, tz = TZ_LOCAL), "%Y")))

# Obtener festivos para todos los a√±os
hols_list <- lapply(years, get_holidays)
hols <- if (length(hols_list)) do.call(rbind, hols_list) else data.frame(date = as.Date(character()))
hols_days <- unique(hols$date)

# Mostrar festivos obtenidos
cat("Total de d√≠as festivos identificados:", length(hols_days), "\n\n")

# Tabla con primeros festivos
head(hols[, c("date", "localName")], 10) %>%
  kable(format = "latex", booktabs = TRUE,
        col.names = c("Fecha", "Nombre"),
        caption = "Primeros d√≠as festivos identificados") %>%
  kable_styling(latex_options = c("striped", "HOLD_position"),
                font_size = 10,
                full_width = FALSE)
```

## Clasificaci√≥n de D√≠as Festivos vs No Festivos

```{r clasificacion-festivos}
# Agregar columna de festivo al dataset diario
daily$holiday <- factor(
  ifelse(daily$fecha %in% hols_days, "Festivo (ES)", "No festivo"),
  levels = c("No festivo", "Festivo (ES)")
)

# Resumen de d√≠as festivos vs no festivos
tabla_festivos <- as.data.frame(table(daily$holiday))
names(tabla_festivos) <- c("Tipo_dia", "Frecuencia")

tabla_festivos %>%
  kable(format = "latex", booktabs = TRUE,
        caption = "Distribuci√≥n de d√≠as en el per√≠odo") %>%
  kable_styling(latex_options = c("striped", "HOLD_position"),
                font_size = 10,
                full_width = FALSE)
```

## Comparativa: Festivo vs No Festivo por D√≠a de la Semana

```{r comparativa-festivo-dia-semana}
# Calcular media diaria por d√≠a de la semana y condici√≥n de festivo
mean_by <- aggregate(accidents ~ day + holiday, data = daily, FUN = mean, na.rm = TRUE)
names(mean_by)[names(mean_by) == "accidents"] <- "mean_acc"

# Contar n√∫mero de d√≠as en cada combinaci√≥n
n_by <- aggregate(fecha ~ day + holiday, data = daily, function(x) length(unique(x)))
names(n_by)[names(n_by) == "fecha"] <- "n_dias"

# Combinar estad√≠sticas
comp_mean <- merge(mean_by, n_by, by = c("day", "holiday"), all = TRUE)
comp_mean <- comp_mean[order(comp_mean$day, comp_mean$holiday), ]

# Mostrar tabla comparativa con formato ajustado
comp_mean %>%
  kable(format = "latex", booktabs = TRUE, 
        digits = 2,
        col.names = c("D√≠a", "Tipo", "Media acc.", "N¬∞ d√≠as"),
        caption = "Media de accidentes por d√≠a de la semana y condici√≥n de festivo") %>%
  kable_styling(latex_options = c("striped", "scale_down", "HOLD_position"),
                font_size = 9,
                full_width = FALSE)
```

```{r plot-festivo-dia-semana, fig.cap="Comparativa de accidentes: festivo vs no festivo por d√≠a de la semana"}
# Visualizaci√≥n comparativa por d√≠a de la semana
pd <- position_dodge(width = 0.8)

ggplot(comp_mean, aes(x = day, y = mean_acc, fill = holiday)) +
  geom_col(position = pd, color = "grey30") +
  geom_text(
    aes(label = sprintf("%.2f", mean_acc)),
    position = pd,
    vjust = -0.35,
    size = 3.3,
    na.rm = TRUE
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.10))) +
  scale_fill_manual(values = c("#9ecae1", "#de2d26")) +
  labs(
    title = "Media de accidentes diarios ‚Äî Festivo vs. No festivo (2019‚Äì2023)",
    subtitle = "Para cada d√≠a: total de accidentes / n√∫mero de d√≠as de ese tipo",
    x = "D√≠a de la semana",
    y = "Media de accidentes diarios",
    fill = ""
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    panel.grid.minor = element_blank()
  )
```

## Comparativa General: Festivo vs No Festivo

```{r comparativa-festivo-general}
# Calcular media diaria por condici√≥n (festivo vs no festivo)
mean_h <- aggregate(accidents ~ holiday, data = daily, FUN = mean, na.rm = TRUE)
names(mean_h)[2] <- "mean_acc"

# Contar n√∫mero de d√≠as en cada grupo
n_h <- aggregate(fecha ~ holiday, data = daily, function(x) length(unique(x)))
names(n_h)[2] <- "n_dias"

# Combinar estad√≠sticas
mean_h <- merge(mean_h, n_h, by = "holiday", all = TRUE)

# Mostrar estad√≠sticas con formato ajustado
mean_h %>%
  kable(format = "latex", booktabs = TRUE, 
        digits = 2,
        col.names = c("Tipo d√≠a", "Media accidentes", "N¬∞ d√≠as"),
        caption = "Estad√≠sticas generales festivo vs no festivo") %>%
  kable_styling(latex_options = c("striped", "HOLD_position"),
                font_size = 10,
                full_width = FALSE)
```

```{r plot-festivo-general, fig.cap="Comparativa general: media de accidentes en d√≠as festivos vs no festivos"}
# Visualizaci√≥n comparativa general
ggplot(mean_h, aes(x = holiday, y = mean_acc, fill = holiday)) +
  geom_col(color = "grey30", width = 0.7, show.legend = FALSE) +
  geom_text(aes(label = sprintf("%.2f", mean_acc)), vjust = -0.35, size = 3.6) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.10))) +
  scale_fill_manual(values = c("#9ecae1", "#de2d26")) +
  labs(
    title = "Media de accidentes ‚Äî Festivo vs. No festivo (2019‚Äì2023)",
    subtitle = "Total de accidentes por condici√≥n / n√∫mero de d√≠as de esa condici√≥n",
    x = "",
    y = "Media de accidentes"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    panel.grid.minor = element_blank()
  )
```

## Resumen Estad√≠stico: Impacto de D√≠as Festivos

```{r resumen-festivos}
# Calcular proporci√≥n de accidentes en festivos
totales <- aggregate(accidents ~ holiday, data = daily, FUN = sum)
prop_holiday <- with(totales, accidents[holiday == "Festivo (ES)"] / sum(accidents))

# Mostrar resumen
cat("\n=== RESUMEN DE AN√ÅLISIS TEMPORAL ===\n\n")

cat("Total de accidentes por condici√≥n:\n")
print(totales)

cat("\nüìä Estad√≠sticas clave:\n")
cat(sprintf("- Proporci√≥n de accidentes en d√≠as festivos: %.2f%%\n", 100 * prop_holiday))
cat(sprintf("- Media en d√≠as festivos: %.2f accidentes/d√≠a\n", 
            mean_h$mean_acc[mean_h$holiday == "Festivo (ES)"]))
cat(sprintf("- Media en d√≠as no festivos: %.2f accidentes/d√≠a\n", 
            mean_h$mean_acc[mean_h$holiday == "No festivo"]))

# Calcular diferencia porcentual
diff_pct <- ((mean_h$mean_acc[mean_h$holiday == "Festivo (ES)"] / 
              mean_h$mean_acc[mean_h$holiday == "No festivo"]) - 1) * 100
cat(sprintf("- Diferencia: %.2f%% %s accidentes en festivos\n", 
            abs(diff_pct), 
            ifelse(diff_pct > 0, "m√°s", "menos")))
```

# An√°lisis Espacial

## Preparaci√≥n de Datos Geoespaciales

```{r preparacion-espacial}
# Filtrar y normalizar coordenadas UTM
accidents_clean_data_filtered <- accidents_clean_data %>%
  filter(!is.na(coordenada_x_utm) & !is.na(coordenada_y_utm)) %>%
  mutate(
    coordenada_x_utm = as.numeric(coordenada_x_utm) / 1000,
    coordenada_y_utm = as.numeric(coordenada_y_utm) / 1000
  ) %>%
  # Filtrar coordenadas v√°lidas para el √°rea metropolitana de Madrid (UTM zona 30N)
  filter(
    coordenada_x_utm >= 430000 & coordenada_x_utm <= 450000,
    coordenada_y_utm >= 4465000 & coordenada_y_utm <= 4485000
  )

# Convertir a objeto espacial SF con proyecci√≥n UTM
accidentes_sf <- st_as_sf(accidents_clean_data_filtered,
                          coords = c("coordenada_x_utm", "coordenada_y_utm"),
                          crs = 25830)

# Transformar a sistema WGS84 (latitud/longitud)
accidentes_sf <- st_transform(accidentes_sf, crs = 4326)
```

## Mapa de Calor de Densidad de Accidentes

```{r mapa-calor}
# Cargar shapefile de los distritos de Madrid
madrid_sf <- st_read("../data/raw/distritos/DISTRITOS.shp")

# Crear mapa de calor superpuesto sobre l√≠mites de distritos
ggplot() +
  # Capa base: l√≠mites administrativos de distritos
  geom_sf(data = madrid_sf, fill = NA, color = "gray40", size = 0.3) +
  
  # Capa de densidad: mapa de calor de accidentes
  stat_density_2d(
    data = accidents_clean_data_filtered,
    aes(x = coordenada_x_utm, y = coordenada_y_utm, fill = ..level..),
    geom = "polygon",
    alpha = 0.6
  ) +
  
  # Escala de color de amarillo (baja densidad) a rojo (alta densidad)
  scale_fill_gradient(low = "yellow", high = "red", name = "Densidad") +
  
  # T√≠tulos y etiquetas
  labs(
    title = "Mapa de calor de accidentes en Madrid",
    subtitle = "Superpuesto sobre distritos (2019-2023)",
    x = "Coordenada X (UTM)",
    y = "Coordenada Y (UTM)",
    caption = "Fuente: Datos Abiertos Madrid"
  ) +
  
  # Estilo visual
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "right"
  )
```

## Mapa de Burbujas por Distrito

```{r mapa-burbujas}
# Normalizar nombres de distrito para evitar problemas de coincidencia
madrid_sf$NOMBRE <- toupper(trimws(madrid_sf$NOMBRE))
accidents_clean_data_filtered$distrito <- toupper(trimws(accidents_clean_data_filtered$distrito))

# Calcular centroides geom√©tricos de cada distrito
centroides_sf <- st_point_on_surface(madrid_sf)
coords <- st_coordinates(centroides_sf)

# Contar accidentes por distrito
accidentes_distrito <- accidents_clean_data_filtered %>%
  count(distrito, name = "n_accidentes")

# Preparar datos para visualizaci√≥n con coordenadas de centroides
datos_mapa <- data.frame(
  distrito = madrid_sf$NOMBRE,
  x = coords[,1],
  y = coords[,2]
) %>%
  left_join(accidentes_distrito, by = c("distrito" = "distrito")) %>%
  mutate(n_accidentes = ifelse(is.na(n_accidentes), 0, n_accidentes))

# Crear mapa con burbujas proporcionales al n√∫mero de accidentes
ggplot() +
  # Capa base: pol√≠gonos de distritos
  geom_sf(data = madrid_sf, fill = "gray95", color = "gray50", size = 0.3) +
  
  # Burbujas: tama√±o proporcional al n√∫mero de accidentes
  geom_point(data = datos_mapa,
             aes(x = x, y = y, size = n_accidentes, color = n_accidentes),
             alpha = 0.7) +
  
  # Escalas de color y tama√±o
  scale_color_gradient(low = "green", high = "#de2d27", name = "Accidentes") +
  scale_size_continuous(range = c(3, 20), name = "Accidentes", labels = comma) +
  
  # Etiquetas de nombre de distrito
  geom_text(data = datos_mapa,
            aes(x = x, y = y, label = distrito),
            size = 2.5, color = "black", vjust = 1.2) +
  
  # T√≠tulos y metadatos
  labs(
    title = "Cantidad de accidentes por distrito",
    subtitle = "Madrid 2019‚Äì2023",
    caption = "Fuente: Datos Abiertos Madrid"
  ) +
  
  # Estilo visual limpio
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "right"
  )
```

# An√°lisis de Factores Humanos

## Distribuci√≥n por Rango de Edad y Sexo

```{r edad-sexo}
ggplot(accidents_clean_data, aes(x = rango_edad, fill = sexo)) + 
  geom_bar(position = "dodge") +
  coord_flip() +
  labs(
    title = "Distribuci√≥n de accidentes por rango de edad y sexo",
    x = "Rango de edad",
    y = "N√∫mero de accidentes",
    fill = "Sexo"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.text.y = element_text(size = 10)
  )
```

# An√°lisis Multivariado

## Matriz de Correlaciones entre Variables Meteorol√≥gicas

```{r correlaciones}
# Seleccionar √∫nicamente variables meteorol√≥gicas num√©ricas
numericas <- accidents_clean_data[, c("wx_temperature", "wx_wind_speed", "wx_precipitation")]

# Calcular matriz de correlaci√≥n
cor_matrix <- cor(numericas, use = "complete.obs")

# Visualizar matriz de correlaciones
corrplot(cor_matrix, method = "color")
```

# An√°lisis Avanzado: Clustering Geogr√°fico

## Identificaci√≥n de Zonas de Alta Concentraci√≥n de Accidentes

```{r clustering-geografico}
# Preparar dataset con solo coordenadas espaciales
datos_geo <- accidents_clean_data_filtered[, c("coordenada_x_utm", "coordenada_y_utm")]

# Aplicar algoritmo K-means con 5 clusters
set.seed(123)
km_result <- kmeans(datos_geo, centers = 5, nstart = 25)

# A√±adir identificador de cluster al dataset
accidents_clean_data_filtered$cluster_zona <- as.factor(km_result$cluster)

# Visualizar clusters identificados
fviz_cluster(km_result, data = datos_geo,
             palette = "jco",
             ggtheme = theme_minimal(),
             main = "Clustering de zonas con accidentes")
```

# Conclusiones

## Resumen de Hallazgos Clave

-   **An√°lisis temporal:** Se identificaron patrones claros en la distribuci√≥n de accidentes por hora, d√≠a de la semana y mes.
-   **Factores meteorol√≥gicos:** Las condiciones clim√°ticas muestran relaci√≥n con la frecuencia de accidentes.
-   **An√°lisis espacial:** Ciertos distritos presentan mayor concentraci√≥n de accidentes.
-   **Clustering geogr√°fico:** Se identificaron 5 zonas principales con caracter√≠sticas similares de siniestralidad.

## Ruta Metodol√≥gica Seguida

1.  **Carga y limpieza de datos:** Tratamiento de valores faltantes y normalizaci√≥n.
2.  **An√°lisis univariante:** Exploraci√≥n de cada variable por separado.
3.  **An√°lisis bivariante:** Relaciones entre clima, tiempo y accidentes.
4.  **An√°lisis temporal y espacial:** Identificaci√≥n de patrones espacio-temporales.
5.  **An√°lisis multivariado:** Correlaciones y clustering.

------------------------------------------------------------------------

**Informaci√≥n del An√°lisis**

-   **Fuente de datos:** [Kaggle](https://www.kaggle.com/datasets/jairoordezpacheco/accidentes-de-trfico-de-madrid-espaa-2019-a-2023)
-   **Per√≠odo analizado:** 2019-2023
-   **Herramientas:** R `r getRversion()`
-   **Fecha de generaci√≥n del informe:** `r Sys.Date()`